// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Simple in-memory lock to replace navigator.locks.
// navigator.locks can hang after F5 refresh when a lock from a previous
// page context is never released. This implementation is synchronous
// within a single page context and won't deadlock across refreshes.
const locks = new Map<string, Promise<any>>();

const inMemoryLock = async (
  name: string,
  acquireTimeout: number,
  fn: () => Promise<any>
) => {
  const startTime = Date.now();

  // Wait for any existing lock with timeout
  while (locks.has(name)) {
    if (Date.now() - startTime > acquireTimeout) {
      console.warn(`inMemoryLock: Timeout waiting for lock "${name}", proceeding anyway`);
      break;
    }
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  // Create a promise for this lock
  let resolveLock: () => void;
  const lockPromise = new Promise<void>(resolve => {
    resolveLock = resolve;
  });
  locks.set(name, lockPromise);

  try {
    return await fn();
  } finally {
    locks.delete(name);
    resolveLock!();
  }
};

/**
 * Read access token directly from localStorage.
 * This bypasses getSession() which can hang.
 */
const getAccessTokenFromStorage = (): string | null => {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        return data.access_token || null;
      }
    }
    return null;
  } catch {
    return null;
  }
};

/**
 * Custom fetch that adds Authorization header from localStorage.
 * This bypasses the potentially hanging getSession() call.
 */
const customFetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
  const token = getAccessTokenFromStorage();

  const headers = new Headers(init?.headers);

  // Only add auth header if we have a token and one isn't already set
  if (token && !headers.has('Authorization')) {
    headers.set('Authorization', `Bearer ${token}`);
  }

  return fetch(input, {
    ...init,
    headers,
  });
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
    lock: inMemoryLock,
  },
  global: {
    fetch: customFetch,
  },
});

/**
 * Singleton data client for fetching data.
 * Uses customFetch which reads token directly from localStorage,
 * bypassing the potentially stuck main client's getSession().
 *
 * This client is used ONLY for data operations (from().select(), etc.)
 * The main 'supabase' client handles auth operations (login, logout, etc.)
 */
let _dataClient: ReturnType<typeof createClient<Database>> | null = null;

export function getDataClient() {
  if (!_dataClient) {
    console.log('[DataClient] Creating singleton data client');
    _dataClient = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: false,  // Don't persist - main client handles that
        autoRefreshToken: false,  // Don't auto-refresh - main client handles that
        storageKey: 'sb-data-client-dummy',  // Use different key to avoid conflicts
      },
      global: {
        fetch: customFetch,  // Uses token from localStorage directly
      },
    });
  }
  return _dataClient;
}

// Keep the old function for backwards compatibility but use the singleton
export function createFreshSupabaseClient() {
  return getDataClient();
}

/**
 * Safe wrapper for getSession() that falls back to localStorage if it hangs.
 * Use this instead of supabase.auth.getSession() throughout the app.
 */
export async function getSessionSafe(timeoutMs = 3000): Promise<{ user: { id: string; email?: string } | null; accessToken: string | null }> {
  try {
    const result = await Promise.race([
      supabase.auth.getSession(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('getSession timeout')), timeoutMs))
    ]) as any;

    const session = result?.data?.session;
    return {
      user: session?.user || null,
      accessToken: session?.access_token || null,
    };
  } catch (err) {
    // Fallback to localStorage
    console.warn('[getSessionSafe] getSession() timed out, using localStorage fallback');
    const stored = readFullSessionFromStorage();
    return {
      user: stored?.user || null,
      accessToken: stored?.accessToken || null,
    };
  }
}

/**
 * Safe wrapper for getUser() that falls back to localStorage if it hangs.
 * Use this instead of supabase.auth.getUser() throughout the app.
 */
export async function getUserSafe(timeoutMs = 3000): Promise<{ id: string; email?: string } | null> {
  try {
    const result = await Promise.race([
      supabase.auth.getUser(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('getUser timeout')), timeoutMs))
    ]) as any;

    return result?.data?.user || null;
  } catch (err) {
    // Fallback to localStorage
    console.warn('[getUserSafe] getUser() timed out, using localStorage fallback');
    const stored = readFullSessionFromStorage();
    return stored?.user || null;
  }
}

/**
 * Reads the full session from localStorage including user data.
 */
function readFullSessionFromStorage(): { user: { id: string; email?: string } | null; accessToken: string | null } | null {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        return {
          user: data.user || null,
          accessToken: data.access_token || null,
        };
      }
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * SYNCHRONOUS helper to get user ID from localStorage.
 * This NEVER hangs because it doesn't call any async Supabase methods.
 * Use this whenever you just need the user ID for filtering/queries.
 */
export function getUserIdFromStorage(): string | null {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        return data.user?.id || null;
      }
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Diagnostic: reads the auth session directly from localStorage,
 * completely bypassing the Supabase client, locks, and getSession().
 * This tells us the raw truth about what's stored.
 */
export function readSessionFromStorage(): { expiresIn: number | null; hasAccessToken: boolean; hasRefreshToken: boolean; userId: string | null } | null {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        const expiresAt = data.expires_at || 0;
        const secondsLeft = expiresAt - Math.floor(Date.now() / 1000);
        return {
          expiresIn: expiresAt ? secondsLeft : null,
          hasAccessToken: !!data.access_token,
          hasRefreshToken: !!data.refresh_token,
          userId: data.user?.id?.substring(0, 8) || null,
        };
      }
    }
    return null;
  } catch {
    return null;
  }
}

export async function validateSession(): Promise<boolean> {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      console.warn('validateSession: No session found');
      window.dispatchEvent(new Event('supabase-session-invalid'));
      return false;
    }

    const expiresAt = session.expires_at; // unix seconds
    if (expiresAt) {
      const secondsLeft = expiresAt - Math.floor(Date.now() / 1000);
      console.log(`validateSession: Token expires in ${secondsLeft}s`);

      if (secondsLeft < 30) {
        console.log('validateSession: Token expired/expiring, refreshing...');
        const { data: { session: refreshed }, error } = await supabase.auth.refreshSession();
        if (error || !refreshed) {
          console.error('validateSession: Refresh failed', error);
          window.dispatchEvent(new Event('supabase-session-invalid'));
          return false;
        }
        console.log('validateSession: Token refreshed successfully');
      }
    }

    return true;
  } catch (err) {
    console.error('validateSession: Check failed', err);
    window.dispatchEvent(new Event('supabase-session-invalid'));
    return false;
  }
}

export async function debugAuthState() {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    const { data: { user } } = await supabase.auth.getUser();

    console.group('Auth Debug State');
    console.log('Session exists:', !!session);
    if (session) {
      const expiresAt = session.expires_at || 0;
      const secondsLeft = expiresAt - Math.floor(Date.now() / 1000);
      console.log('Token expires in:', secondsLeft, 'seconds');
      console.log('Access token (first 20 chars):', session.access_token?.substring(0, 20));
      console.log('Refresh token exists:', !!session.refresh_token);
    }
    console.log('User from getUser():', user?.id || 'null');
    console.log('User email:', user?.email || 'null');
    console.groupEnd();
  } catch (err) {
    console.error('debugAuthState: Failed', err);
  }
}
