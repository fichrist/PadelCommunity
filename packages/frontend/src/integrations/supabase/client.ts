// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Simple in-memory lock to replace navigator.locks.
// navigator.locks can hang after F5 refresh when a lock from a previous
// page context is never released. This implementation is synchronous
// within a single page context and won't deadlock across refreshes.
const locks = new Map<string, Promise<any>>();

const inMemoryLock = async (
  name: string,
  _acquireTimeout: number,
  fn: () => Promise<any>
) => {
  // Use 60s timeout instead of Supabase's default (which can be too short
  // for slow token refresh after long inactivity)
  const acquireTimeout = 60000;
  const startTime = Date.now();

  // Wait for any existing lock with timeout
  while (locks.has(name)) {
    if (Date.now() - startTime > acquireTimeout) {
      throw new Error(`inMemoryLock: Timeout waiting for lock "${name}" after 60s`);
    }
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  // Create a promise for this lock
  let resolveLock: () => void;
  const lockPromise = new Promise<void>(resolve => {
    resolveLock = resolve;
  });
  locks.set(name, lockPromise);

  try {
    return await fn();
  } finally {
    locks.delete(name);
    resolveLock!();
  }
};

/**
 * Read access token directly from localStorage.
 * This bypasses getSession() which can hang.
 */
const getAccessTokenFromStorage = (): string | null => {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        return data.access_token || null;
      }
    }
    return null;
  } catch {
    return null;
  }
};

/**
 * Read refresh token directly from localStorage.
 */
const getRefreshTokenFromStorage = (): string | null => {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        return data.refresh_token || null;
      }
    }
    return null;
  } catch {
    return null;
  }
};

/**
 * Get the localStorage key for the auth token.
 */
const getAuthStorageKey = (): string | null => {
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
      return key;
    }
  }
  return null;
};

/**
 * Custom fetch that adds Authorization header from localStorage.
 * This bypasses the potentially hanging getSession() call.
 * Token refresh is handled by the keepalive timer and visibility handler,
 * NOT inline here — to avoid adding latency to every data request.
 */
const customFetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
  const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : (input as Request).url;
  const isAuthRequest = url.includes('/auth/v1/');

  // For data requests: if the token expires within 60s, refresh it first
  if (!isAuthRequest) {
    const secondsLeft = getTokenExpirySeconds();
    if (secondsLeft !== null && secondsLeft < 60) {
      console.log(`[customFetch] Token expires in ${secondsLeft}s, refreshing before request...`);
      await directTokenRefresh();
    }
  }

  const token = getAccessTokenFromStorage();
  const headers = new Headers(init?.headers);

  // Override Authorization with the user's JWT for data (PostgREST) requests
  // so that RLS (auth.uid()) works. But SKIP auth endpoint requests —
  // those need the anon key in Authorization, and overriding with an expired
  // user JWT would cause token refresh to fail after inactivity.
  if (token && !isAuthRequest) {
    headers.set('Authorization', `Bearer ${token}`);
  }

  // 60s timeout for every Supabase request
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 60000);

  try {
    return await fetch(input, {
      ...init,
      headers,
      signal: controller.signal,
    });
  } finally {
    clearTimeout(timeoutId);
  }
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
    lock: inMemoryLock,
  },
  global: {
    fetch: customFetch,
  },
});

// =====================================================
// PROACTIVE TOKEN REFRESH
// =====================================================
// Keeps the access token fresh by proactively refreshing
// every 10 minutes, instead of waiting until it expires.
// This prevents RLS errors after inactivity.

/**
 * Read token expiry from localStorage (seconds until expiry).
 * Returns null if no session found.
 */
function getTokenExpirySeconds(): number | null {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        const expiresAt = data.expires_at || 0;
        if (!expiresAt) return null;
        return expiresAt - Math.floor(Date.now() / 1000);
      }
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Direct token refresh via Supabase REST API.
 * Bypasses the client's internal lock/session machinery entirely.
 * Used as fallback when supabase.auth.refreshSession() hangs.
 */
async function directTokenRefresh(): Promise<boolean> {
  const refreshToken = getRefreshTokenFromStorage();
  const storageKey = getAuthStorageKey();
  if (!refreshToken || !storageKey) {
    console.error('[directTokenRefresh] No refresh token or storage key found');
    return false;
  }

  console.log('[directTokenRefresh] Calling auth API directly...');
  const response = await fetch(`${SUPABASE_URL}/auth/v1/token?grant_type=refresh_token`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'apikey': SUPABASE_ANON_KEY,
    },
    body: JSON.stringify({ refresh_token: refreshToken }),
  });

  if (!response.ok) {
    console.error('[directTokenRefresh] API returned', response.status);
    return false;
  }

  const data = await response.json();
  if (!data.access_token || !data.refresh_token) {
    console.error('[directTokenRefresh] Invalid response data');
    return false;
  }

  // Write the new session directly into localStorage
  const existing = JSON.parse(localStorage.getItem(storageKey) || '{}');
  existing.access_token = data.access_token;
  existing.refresh_token = data.refresh_token;
  existing.expires_at = data.expires_at;
  existing.expires_in = data.expires_in;
  if (data.user) existing.user = data.user;
  localStorage.setItem(storageKey, JSON.stringify(existing));

  // Fire-and-forget: don't await because setSession can hang
  // localStorage is already updated, and customFetch reads from there
  supabase.auth.setSession({
    access_token: data.access_token,
    refresh_token: data.refresh_token,
  }).catch(err => {
    console.warn('[directTokenRefresh] setSession sync failed (non-blocking):', err);
  });

  const newExpiry = getTokenExpirySeconds();
  console.log(`[directTokenRefresh] Succeeded, new expiry in ${newExpiry}s`);
  return true;
}

/**
 * Force-trigger a token refresh.
 * Uses directTokenRefresh() as primary method because supabase.auth.refreshSession()
 * can hang due to internal locking issues, while direct API calls are fast (~600ms).
 */
export async function syncRefreshToken(): Promise<boolean> {
  try {
    const secondsLeft = getTokenExpirySeconds();
    if (secondsLeft === null) {
      console.log('[syncRefreshToken] No session found, skipping');
      return false;
    }

    console.log(`[syncRefreshToken] Token expires in ${secondsLeft}s, refreshing via direct API...`);
    return await directTokenRefresh();
  } catch (err: any) {
    console.error('[syncRefreshToken] Error:', err.message);
    return false;
  }
}

/**
 * Proactive keepalive: refreshes the token every 10 minutes.
 * This ensures the token never expires during inactivity.
 * Multiple attempts are made if refresh fails.
 */
let _keepaliveInterval: ReturnType<typeof setInterval> | null = null;

function startTokenKeepalive() {
  // Don't start multiple intervals
  if (_keepaliveInterval) return;

  const KEEPALIVE_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes
  const MAX_RETRY_ATTEMPTS = 3;
  const RETRY_DELAY_MS = 5000; // 5 seconds between retries

  console.log('[TokenKeepalive] Starting proactive token refresh (every 5 min)');

  _keepaliveInterval = setInterval(async () => {
    const userId = getUserIdFromStorage();
    if (!userId) {
      // No user logged in, skip
      return;
    }

    console.log('[TokenKeepalive] Proactive refresh...');

    let success = false;
    for (let attempt = 1; attempt <= MAX_RETRY_ATTEMPTS; attempt++) {
      success = await directTokenRefresh();
      if (success) break;

      console.warn(`[TokenKeepalive] Attempt ${attempt}/${MAX_RETRY_ATTEMPTS} failed`);
      if (attempt < MAX_RETRY_ATTEMPTS) {
        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
      }
    }

    if (!success) {
      console.error('[TokenKeepalive] All refresh attempts failed, session may be invalid');
      window.dispatchEvent(new Event('supabase-session-invalid'));
    }
  }, KEEPALIVE_INTERVAL_MS);
}

function stopTokenKeepalive() {
  if (_keepaliveInterval) {
    clearInterval(_keepaliveInterval);
    _keepaliveInterval = null;
    console.log('[TokenKeepalive] Stopped');
  }
}

// Start keepalive when there's a logged-in user
if (getUserIdFromStorage()) {
  startTokenKeepalive();
  console.log('[Init] User logged in, doing immediate token refresh...');
  directTokenRefresh();
}

// Manage keepalive based on auth state
supabase.auth.onAuthStateChange((event) => {
  if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
    startTokenKeepalive();
  } else if (event === 'SIGNED_OUT') {
    stopTokenKeepalive();
  }
});

// Also refresh proactively when the page becomes visible again after being hidden
// (e.g., user switches back to the tab after being away)
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible') {
    const userId = getUserIdFromStorage();
    if (!userId) return;

    console.log('[visibilitychange] Tab visible again, refreshing token...');
    await directTokenRefresh();
  }
});

/**
 * Singleton data client for fetching data.
 * Uses customFetch which reads token directly from localStorage,
 * bypassing the potentially stuck main client's getSession().
 *
 * This client is used ONLY for data operations (from().select(), etc.)
 * The main 'supabase' client handles auth operations (login, logout, etc.)
 */
let _dataClient: ReturnType<typeof createClient<Database>> | null = null;

export function getDataClient() {
  if (!_dataClient) {
    console.log('[DataClient] Creating singleton data client');
    _dataClient = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: false,  // Don't persist - main client handles that
        autoRefreshToken: false,  // Don't auto-refresh - main client handles that
        storageKey: 'sb-data-client-dummy',  // Use different key to avoid conflicts
      },
      global: {
        fetch: customFetch,  // Uses token from localStorage directly
      },
    });
  }
  return _dataClient;
}

// Keep the old function for backwards compatibility but use the singleton
export function createFreshSupabaseClient() {
  return getDataClient();
}

/**
 * Safe wrapper for getSession() that falls back to localStorage if it hangs.
 * Use this instead of supabase.auth.getSession() throughout the app.
 */
export async function getSessionSafe(timeoutMs = 60000): Promise<{ user: { id: string; email?: string } | null; accessToken: string | null }> {
  try {
    const result = await Promise.race([
      supabase.auth.getSession(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('getSession timeout')), timeoutMs))
    ]) as any;

    const session = result?.data?.session;
    return {
      user: session?.user || null,
      accessToken: session?.access_token || null,
    };
  } catch (err) {
    // Fallback to localStorage
    console.warn('[getSessionSafe] getSession() timed out, using localStorage fallback');
    const stored = readFullSessionFromStorage();
    return {
      user: stored?.user || null,
      accessToken: stored?.accessToken || null,
    };
  }
}

/**
 * Safe wrapper for getUser() that falls back to localStorage if it hangs.
 * Use this instead of supabase.auth.getUser() throughout the app.
 */
export async function getUserSafe(timeoutMs = 60000): Promise<{ id: string; email?: string } | null> {
  try {
    const result = await Promise.race([
      supabase.auth.getUser(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('getUser timeout')), timeoutMs))
    ]) as any;

    return result?.data?.user || null;
  } catch (err) {
    // Fallback to localStorage
    console.warn('[getUserSafe] getUser() timed out, using localStorage fallback');
    const stored = readFullSessionFromStorage();
    return stored?.user || null;
  }
}

/**
 * Reads the full session from localStorage including user data.
 */
function readFullSessionFromStorage(): { user: { id: string; email?: string } | null; accessToken: string | null } | null {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        return {
          user: data.user || null,
          accessToken: data.access_token || null,
        };
      }
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * SYNCHRONOUS helper to get user ID from localStorage.
 * This NEVER hangs because it doesn't call any async Supabase methods.
 * Use this whenever you just need the user ID for filtering/queries.
 */
export function getUserIdFromStorage(): string | null {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        return data.user?.id || null;
      }
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Diagnostic: reads the auth session directly from localStorage,
 * completely bypassing the Supabase client, locks, and getSession().
 * This tells us the raw truth about what's stored.
 */
export function readSessionFromStorage(): { expiresIn: number | null; hasAccessToken: boolean; hasRefreshToken: boolean; userId: string | null } | null {
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('sb-') && key.endsWith('-auth-token')) {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const data = JSON.parse(raw);
        const expiresAt = data.expires_at || 0;
        const secondsLeft = expiresAt - Math.floor(Date.now() / 1000);
        return {
          expiresIn: expiresAt ? secondsLeft : null,
          hasAccessToken: !!data.access_token,
          hasRefreshToken: !!data.refresh_token,
          userId: data.user?.id?.substring(0, 8) || null,
        };
      }
    }
    return null;
  } catch {
    return null;
  }
}

export async function validateSession(): Promise<boolean> {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      console.warn('validateSession: No session found');
      window.dispatchEvent(new Event('supabase-session-invalid'));
      return false;
    }

    const expiresAt = session.expires_at; // unix seconds
    if (expiresAt) {
      const secondsLeft = expiresAt - Math.floor(Date.now() / 1000);
      console.log(`validateSession: Token expires in ${secondsLeft}s`);

      if (secondsLeft < 30) {
        console.log('validateSession: Token expired/expiring, refreshing...');
        const { data: { session: refreshed }, error } = await supabase.auth.refreshSession();
        if (error || !refreshed) {
          console.error('validateSession: Refresh failed', error);
          window.dispatchEvent(new Event('supabase-session-invalid'));
          return false;
        }
        console.log('validateSession: Token refreshed successfully');
      }
    }

    return true;
  } catch (err) {
    console.error('validateSession: Check failed', err);
    window.dispatchEvent(new Event('supabase-session-invalid'));
    return false;
  }
}

export async function debugAuthState() {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    const { data: { user } } = await supabase.auth.getUser();

    console.group('Auth Debug State');
    console.log('Session exists:', !!session);
    if (session) {
      const expiresAt = session.expires_at || 0;
      const secondsLeft = expiresAt - Math.floor(Date.now() / 1000);
      console.log('Token expires in:', secondsLeft, 'seconds');
      console.log('Access token (first 20 chars):', session.access_token?.substring(0, 20));
      console.log('Refresh token exists:', !!session.refresh_token);
    }
    console.log('User from getUser():', user?.id || 'null');
    console.log('User email:', user?.email || 'null');
    console.groupEnd();
  } catch (err) {
    console.error('debugAuthState: Failed', err);
  }
}

// =====================================================
// FILTERED GROUPS CACHE
// =====================================================
// Cache filtered_groups in localStorage for faster loading
// on the community page. Updated when user changes filters.

const FILTERED_GROUPS_CACHE_KEY = 'padel-filtered-groups-cache';

export interface FilteredGroupsCache {
  userId: string;
  filtered_groups: string[];
  filtered_address: string | null;
  filtered_latitude: number | null;
  filtered_longitude: number | null;
  filtered_radius_km: number | null;
  cachedAt: number; // timestamp
}

/**
 * Get cached filtered_groups from localStorage.
 * Returns null if no cache exists or cache is for a different user.
 */
export function getFilteredGroupsFromCache(): FilteredGroupsCache | null {
  try {
    const userId = getUserIdFromStorage();
    if (!userId) return null;

    const raw = localStorage.getItem(FILTERED_GROUPS_CACHE_KEY);
    if (!raw) return null;

    const cache = JSON.parse(raw) as FilteredGroupsCache;

    // Ensure cache is for the current user
    if (cache.userId !== userId) {
      console.log('[FilteredGroupsCache] Cache is for different user, clearing');
      localStorage.removeItem(FILTERED_GROUPS_CACHE_KEY);
      return null;
    }

    return cache;
  } catch {
    return null;
  }
}

/**
 * Save filtered_groups to localStorage cache.
 */
export function setFilteredGroupsCache(data: Omit<FilteredGroupsCache, 'userId' | 'cachedAt'>): void {
  try {
    const userId = getUserIdFromStorage();
    if (!userId) return;

    const cache: FilteredGroupsCache = {
      ...data,
      userId,
      cachedAt: Date.now(),
    };

    localStorage.setItem(FILTERED_GROUPS_CACHE_KEY, JSON.stringify(cache));
    console.log('[FilteredGroupsCache] Cache updated:', cache.filtered_groups?.length, 'groups');
  } catch (err) {
    console.error('[FilteredGroupsCache] Failed to save cache:', err);
  }
}

/**
 * Clear the filtered_groups cache (e.g., on logout).
 */
export function clearFilteredGroupsCache(): void {
  try {
    localStorage.removeItem(FILTERED_GROUPS_CACHE_KEY);
    console.log('[FilteredGroupsCache] Cache cleared');
  } catch {
    // Ignore errors
  }
}

// Clear cache on logout
supabase.auth.onAuthStateChange((event) => {
  if (event === 'SIGNED_OUT') {
    clearFilteredGroupsCache();
  }
});
