// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Wrap fetch with a 10-second timeout so Supabase requests (including
// internal token refreshes) can never hang indefinitely. Without this,
// an unreachable Supabase server (e.g. paused free-tier project, network
// issue after sleep) causes getSession() to hang and the app to freeze.
const fetchWithTimeout: typeof fetch = (input, init) => {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 10000);

  // If the caller already provided a signal, listen to it as well.
  if (init?.signal) {
    init.signal.addEventListener('abort', () => controller.abort());
  }

  return fetch(input, { ...init, signal: controller.signal })
    .finally(() => clearTimeout(timeout));
};

// Supabase v2 uses navigator.locks to coordinate auth sessions across
// browser tabs. This can cause the entire app to freeze when a lock from
// a previous context (e.g. before F5 refresh, after sleep) is never
// released. Every Supabase query internally calls getSession() which
// waits on this lock, so a stuck lock hangs ALL data fetching silently.
//
// This in-memory lock serializes operations with the same name within
// the current tab, while avoiding the cross-tab navigator.locks that can
// persist across page refreshes. It uses a timeout so that if a previous
// operation gets permanently stuck, subsequent operations still proceed
// (falling back to concurrent execution rather than deadlocking).
const inMemoryLock = (() => {
  const pending = new Map<string, Promise<void>>();

  return async (
    name: string,
    acquireTimeout: number,
    fn: () => Promise<any>
  ): Promise<any> => {
    // Wait for any pending operation, but never longer than the timeout.
    const existing = pending.get(name);
    if (existing) {
      const timeoutMs = Math.max(acquireTimeout || 5000, 1000);
      await Promise.race([
        existing,
        new Promise<void>(resolve => setTimeout(resolve, timeoutMs)),
      ]).catch(() => {});
    }

    // Track our own operation so the next caller can wait for us.
    let done!: () => void;
    const ourLock = new Promise<void>(r => { done = r; });
    pending.set(name, ourLock);

    try {
      return await fn();
    } finally {
      done();
      if (pending.get(name) === ourLock) {
        pending.delete(name);
      }
    }
  };
})();

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
    lock: inMemoryLock,
  },
  global: {
    fetch: fetchWithTimeout,
  },
});