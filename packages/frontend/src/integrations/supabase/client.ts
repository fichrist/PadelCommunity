// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Wrap fetch with a 10-second timeout so Supabase requests (including
// internal token refreshes) can never hang indefinitely. Without this,
// an unreachable Supabase server (e.g. paused free-tier project, network
// issue after sleep) causes getSession() to hang and the app to freeze.
const fetchWithTimeout: typeof fetch = (input, init) => {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 10000);

  // If the caller already provided a signal, listen to it as well.
  if (init?.signal) {
    init.signal.addEventListener('abort', () => controller.abort());
  }

  return fetch(input, { ...init, signal: controller.signal })
    .finally(() => clearTimeout(timeout));
};

// Bypass navigator.locks which can hang after F5 refresh when a lock from
// a previous page context is never released. The 5-second auth timeout in
// AppLayout handles the rare case where getSession() still stalls.
const navigatorLockNoOp = async (
  _name: string,
  _acquireTimeout: number,
  fn: () => Promise<any>
) => {
  return await fn();
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
    lock: navigatorLockNoOp,
  },
  global: {
    fetch: fetchWithTimeout,
  },
});

/**
 * Validate the current session before making queries.
 * Supabase queries with an expired JWT don't return errors â€” RLS policies
 * silently filter all rows, returning empty arrays. This function detects
 * that situation and tries to refresh the token. If recovery fails it
 * dispatches 'supabase-session-invalid' so the app can redirect to login.
 *
 * @returns true if the session is valid and queries can proceed.
 */
export async function validateSession(): Promise<boolean> {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      console.warn('validateSession: No session found');
      window.dispatchEvent(new Event('supabase-session-invalid'));
      return false;
    }

    const expiresAt = session.expires_at; // unix seconds
    if (expiresAt) {
      const secondsLeft = expiresAt - Math.floor(Date.now() / 1000);
      console.log(`validateSession: Token expires in ${secondsLeft}s`);

      if (secondsLeft < 30) {
        console.log('validateSession: Token expired/expiring, refreshing...');
        const { data: { session: refreshed }, error } = await supabase.auth.refreshSession();
        if (error || !refreshed) {
          console.error('validateSession: Refresh failed', error);
          window.dispatchEvent(new Event('supabase-session-invalid'));
          return false;
        }
        console.log('validateSession: Token refreshed successfully');
      }
    }

    return true;
  } catch (err) {
    console.error('validateSession: Check failed', err);
    window.dispatchEvent(new Event('supabase-session-invalid'));
    return false;
  }
}

/**
 * Log the current auth state to the console for debugging.
 * Call from a button or useEffect to diagnose session issues.
 */
export async function debugAuthState() {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    const { data: { user } } = await supabase.auth.getUser();

    console.group('Auth Debug State');
    console.log('Session exists:', !!session);
    if (session) {
      const expiresAt = session.expires_at || 0;
      const secondsLeft = expiresAt - Math.floor(Date.now() / 1000);
      console.log('Token expires in:', secondsLeft, 'seconds');
      console.log('Access token (first 20 chars):', session.access_token?.substring(0, 20));
      console.log('Refresh token exists:', !!session.refresh_token);
    }
    console.log('User from getUser():', user?.id || 'null');
    console.log('User email:', user?.email || 'null');
    console.groupEnd();
  } catch (err) {
    console.error('debugAuthState: Failed', err);
  }
}